# -*- coding: utf-8 -*-

"""
Online Model Adaptation in Monte Carlo Tree Search Planning

This file is part of free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

It is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with the code.  If not, see <http://www.gnu.org/licenses/>.
"""


import math
import os
import random
from datetime import datetime

import utils
from action_data import ActionData
from safeplace_env import SafePlaceEnv
from state_data import StateData


class DatasetGeneration(SafePlaceEnv):
    """
    Subclass of `SafePlaceEnv`. Class responsible for i) creating datasets used by the neural network for training and
    ii) using the expert's transition model.
    """

    def __init__(self) -> None:
        """
        Method called after the creation of the object. It does nothing.
        """
        pass

    @staticmethod
    def generate_trajectories(iterations: int, real_env: bool, seeds: tuple, save_file=True) -> str:
        """
        Generates a csv dataset that can be used by the neural network for training.

        Args:
            iterations: number of lines of the resulting dataset
            real_env: set to True if you want train your neural network on data generated by the oracle; otherwise,
                the data will be generated by the expert's model.
            seeds: tuple of integers the ensures reproducibility for the room reservations profiles. Its length must be
            equal to `iterations`.
            save_file: set to True if you want to save the dataset to your file system; otherwise, the function will not
                save the generated dataset (you will not be able to retrieve it afterwards). Default to True.

        Returns: `filename` string that indicates the dataset location in the file system (this string will not be empty
            even though `save_file` is set to False).
        """
        if len(seeds) != iterations:
            utils.error('(generate_trajectories) `seeds` length is different from `iterations`.')

        string = utils.dataset_header
        for iteration in range(iterations):
            random.seed(seeds[iteration])
            reservations_string, _ = utils.generate_reservations_file()
            utils.update_reservations(string=reservations_string, random_initial_temp_in=True)

            initial_state = utils.initial_state()
            s: StateData = initial_state

            while not s.is_terminal:
                a = random.choice(list(ActionData))
                next_s = DatasetGeneration.get_next_state(s, a, real_env=real_env)

                csv_row = DatasetGeneration.extract_transition_data(s, a, next_s)
                string += csv_row

                s = next_s

        timestamp = datetime.utcnow().strftime('%y%m%d_%H%M%S')
        if real_env:
            folder = 'datasets/real_transition_model'
            filename = folder + '/rtm_dataset_' + timestamp + '.csv'
        else:
            folder = 'datasets/expert_dataset'
            filename = folder + '/expert_dataset.csv'

        if save_file:
            if not os.path.exists(folder):
                os.makedirs(folder)

            with open(filename, 'a') as f:
                f.write(string)

        return filename

    @staticmethod
    def extract_transition_data(s: StateData, a: ActionData, next_s: StateData) -> str:
        """
        Takes an MDP transition and converts it to the csv format.

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.
            next_s: `StateData` object representing the next state.

        Returns: a string in csv format.
        """
        window_open = 1 if a.is_window_open else 0
        sanitizer_active = 1 if a.is_sanitizer_active else 0

        return '%d,%f,%f,%f,%f,%d,%f,%d,%f,%f,%f\n' % (s.people,
                                                       s.co2,
                                                       s.voc,
                                                       s.temp_in,
                                                       s.temp_out,
                                                       window_open,
                                                       a.ach,
                                                       sanitizer_active,
                                                       next_s.co2,
                                                       next_s.voc,
                                                       next_s.temp_in
                                                       )

    @staticmethod
    def convert_state_action_pair(s: StateData, a: ActionData) -> tuple[tuple, tuple, list]:
        """
        Takes a state-action pair and converts it to types compatible with the neural network and
        `utils.states_are_close` method.

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.

        Returns: the converted pair in two tuples (used by `states_are_close`) and one list (used by the NN)
        """
        window_open = 1 if a.is_window_open else 0
        sanitizer_active = 1 if a.is_sanitizer_active else 0

        return (s.people, s.co2, s.voc, s.temp_in, s.temp_out), (window_open, a.ach, sanitizer_active), \
               [s.people, s.co2, s.voc, s.temp_in, s.temp_out, window_open, a.ach, sanitizer_active]

    @staticmethod
    def get_next_state(s: StateData, a: ActionData, real_env: bool) -> StateData:
        """
        Exclusively used by `DatasetGeneration.generate_trajectories()` for selectively choosing the transition model
        following `real_env` parameter.

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.
            real_env: set to True if you want to use the oracle's transition model; otherwise, the transition will be
                generated by the expert's model.

        Returns: the next `StateData` object representing the next state in the MDP.
        """
        if real_env is True:
            return SafePlaceEnv.transition_model(s, a)
        else:
            return DatasetGeneration.simple_transition_model(s, a)

    @staticmethod
    def simple_transition_model(s: StateData, a: ActionData) -> StateData:
        """
        Expert's transition model. It predicts the next CO2 and VOCs concentrations and the next indoor temperature.
        In addition, uses the `utils.reservations` and `utils.referenced_reservations` dicts to get the next time and
        next forecasted outdoor temperature (that we assume to be the real one).

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.

        Returns: the next `StateData` object representing the next state in the MDP.
        """
        hour = s.hour
        minute = s.minute
        people = s.people
        co2 = s.co2
        voc = s.voc
        temp_in = s.temp_in
        temp_out = s.temp_out

        # get next_hour and next_minute
        next_hour, next_minute = SafePlaceEnv.next_time(hour, minute)

        # get next_people and next_temp_out
        next_people = utils.reservations[next_hour][next_minute].people
        next_temp_out = utils.reservations[next_hour][next_minute].temp_out

        # get next_co2
        next_co2 = DatasetGeneration.next_co2(co2, people, a)

        # get next_voc
        next_voc = DatasetGeneration.next_voc(voc, people, a)

        # get next_temp_in
        next_temp_in = DatasetGeneration.next_temp_in(temp_in, temp_out, a)

        # get next_s
        next_s = StateData(next_hour, next_minute, next_people, next_co2, next_voc, next_temp_in, next_temp_out)

        return next_s

    @staticmethod
    def simulate(s: StateData, a: ActionData) -> (StateData, float):
        """
        Function used as interface for outside modules to obtain the next state and reward of the MDP transition.
        Exclusively used in MCTS simulation.

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.

        Returns: i) the next `StateData` object representing the next state in the MDP and ii) the resulting reward.
        """
        next_s = DatasetGeneration.simple_transition_model(s, a)

        reward, _, _, _ = SafePlaceEnv.get_reward(s, a, next_s)

        return next_s, reward

    @staticmethod
    def get_prediction_error(s: StateData, a: ActionData) -> list[float, float, float]:
        """
        Compares the predictions of the expert's model with the oracle's model ones and returns them as a list.

        Args:
            s: `StateData` object representing the current state.
            a: `ActionData` object representing the action.

        Returns: prediction errors as a list.
        """
        real_next_s = SafePlaceEnv.transition_model(s, a)

        real_co2, real_voc, real_temp = real_next_s.co2, real_next_s.voc, real_next_s.temp_in

        other_next_s = DatasetGeneration.simple_transition_model(s, a)
        other_co2, other_voc, other_temp = other_next_s.co2, other_next_s.voc, other_next_s.temp_in

        errors = [abs(other_co2 - real_co2), abs(other_voc - real_voc), abs(other_temp - real_temp)]

        if utils.execnet:
            if utils.verbose:
                print('Prediction errors - absolute values - [`co2`, `voc`, `temp_in`]: ' + str(errors))

        return errors

    @staticmethod
    def next_co2(co2, people, action) -> float:
        """
        Sub-model of the expert's transition function that predicts the next indoor CO2 concentration.
        The computation depends on:
            - the current indoor CO2 concentration (ppm)
            - the current number of people inside the room (person)
            - the action's ACH (air changes per hour) (h^(-1))
            - the time difference between the current CO2 concentration and the predicted one (min)
            - the room volume (m^3)
            - the outdoor CO2 concentration (ppm)
        Some values are directly taken from the `utils` module.

        Args:
            co2: the current indoor CO2 concentration.
            people: the current number of people inside the room.
            action: the `ActionData` object representing the action.

        Returns: the predicted next indoor CO2 concentration.
        """
        if action.is_stack_ventilation_compatible:
            if people > 0:
                next_co2 = co2 + people * utils.time_delta / (action.ach * 150)
            else:
                if action.is_ventilation_active:
                    next_co2 = co2 - action.ach * 20000 / utils.room_volume
                else:
                    next_co2 = co2 - 100
        else:
            next_co2 = co2 - action.ach * 30000 / utils.room_volume

        if next_co2 < utils.outdoor_co2:
            next_co2 = utils.outdoor_co2

        return next_co2

    @staticmethod
    def next_voc(voc, people, action) -> float:
        """
        Sub-model of the expert's transition function that predicts the next indoor VOCs concentration.
        The computation depends on:
            - the current indoor VOCs concentration (µg * m^(-3))
            - the current number of people inside the room (person)
            - the action's ACH (air changes per hour) (h^(-1))
            - the time difference between the current VOCs concentration and the predicted one (min) (implicit since in
                our experiments `utils.time_delta` has always been equal to 5)
            - the room volume (m^3)
            - the outdoor VOCs concentration (µg * m^(-3))
            - the sanitizer VOCs removal rate (µg) (again, the time is implicit, i.e., VOCs removed every 5 minutes)
        Some values are directly taken from the `utils` module.

        Args:
            voc: the current indoor VOCs concentration.
            people: the current number of people inside the room.
            action: the `ActionData` object representing the action.

        Returns: the predicted next indoor VOCs concentration.
        """
        if action.is_sanitizer_active and action.is_ventilation_active:
            voc_removed = utils.voc_removal_rate * action.ach / 7 * 2
        elif not action.is_sanitizer_active and action.is_ventilation_active:
            voc_removed = utils.voc_removal_rate * action.ach / 7
        elif action.is_sanitizer_active and not action.is_ventilation_active:
            voc_removed = utils.voc_removal_rate
        else:
            voc_removed = 0

        if people > 0:
            voc_produced = 100 * people
        else:
            voc_produced = 0

        voc_delta = voc_produced - voc_removed
        voc_delta_concentration = voc_delta / utils.room_volume

        next_voc = voc + voc_delta_concentration

        if next_voc < utils.outdoor_voc:
            next_voc = utils.outdoor_voc

        return next_voc

    @staticmethod
    def next_temp_in(temp_in, temp_out, action) -> float:
        """
        Sub-model of the expert's transition function that predicts the next indoor temperature.
        The computation depends on:
            - the current indoor temperature (°C)
            - the current outdoor temperature (°C)
            - the action's ACH (air changes per hour) (h^(-1))
            - the time difference between the current indoor temperature and the predicted one (min) (implicit since in
                our experiments `utils.time_delta` has always been equal to 5)

        Args:
            temp_in: the current indoor temperature.
            temp_out: the current outdoor temperature.
            action: the `ActionData` object representing the action.

        Returns: the predicted next indoor temperature.
        """
        if action.is_window_open:
            delta = temp_out - temp_in
            sign = math.copysign(1, delta)
            delta = abs(delta)

            new_delta = delta / 1.5

            new_delta = math.copysign(new_delta, sign)
            next_temp_in = temp_in + new_delta
        else:
            next_temp_in = temp_in

        return next_temp_in
